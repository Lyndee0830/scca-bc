#' @export
pps <- function(s_res, row_mode, col_mode)
{
    stopifnot( is(s_res, "sccab_result") )
    row_func <- get_pps(row_mode)
    col_func <- get_pps(col_mode)

    row_idx <- row_func(s_res$AB)
    col_idx <- col_func(s_res$D)


    list(rowIdx = row_idx, colIdx = col_idx)
}

# TODO: write docs
#' @export
get_pps <- function(pps_mode)
{
    stopifnot( is(pps_mode, "character") || is(pps_mode, "function"))

    if (is(pps_mode, "function") )
        return(pps_mode)

    switch(pps_mode,
        "pca" = pps_pca.matrix,
        "rank_pca" = pps_ranks.matrix,
        "hclust" = pps_hclust.matrix,
        stop("Unrecognized post-processing mode. Please see docs for get_pps")
        )
}

#' @export
pps_pca.matrix <- function(res)
{
    if ( any(is.na(res)) )
        res <- bootStrapNAs(res, 0.05, 0.95)

    res <- t(res)

    pca <- prcomp(res, center = F, scale. = F)


    features <- cbind(-pca$rotation[,'PC1'] * pca$sdev[1],
        pca$rotation[,'PC2'] * pca$sdev[2])

    idx <- clustKmeans(features)

    features <- as.data.frame(features)
    features$cluster <- FALSE
    features$cluster[idx] <- TRUE

    list(idx = idx, features = features)
}


#' @export
pps_hclust.matrix <- function(res)
{
    cutHCluster <- function(mat)
    {
        hc <- hclust(dist(mat))
        hcCuts <- cutree(hc, 2)

        cutIdx <- 1
        if (mean(mat[which(hcCuts == 1), ]) <
            mean(mat[which(hcCuts == 2), ]))
        {
            cutIdx <- 2
        }
        cutIdx <- which(hcCuts == cutIdx)

        return(cutIdx)
    }

    idx <- cutHCluster(res)

    list(idx = idx)
}

#' @export
clustKmeans <- function(dat, minK = 2, add_noise = T)
{
    dat <- round(dat, 6)
    if (add_noise)
        dat <- dat + rnorm(nrow(dat) * ncol(dat), mean = 0, sd = 0.00001)

    gap <- cluster::clusGap(as.matrix(dat), kmeans, 5)
    nk <- cluster::maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"])
    if (nk == 1)
        nk <- minK
    cat("Conditions k: ", nk, "\n")
    kRes <- kmeans(dat, nk, nstart = 20)
    kMax <- which.max(kRes$centers[,1])

    which(kRes$cluster == kMax)
}


#' @export
pps_ranks.matrix <- function(res)
{
    if ( any(is.na(res)) )
        res <- bootStrapNAs(res, 0.05, 0.95)

    res_ranks <- apply(res, 2, rank, na.last = "keep")

    pca <- prcomp(t(res_ranks), center = F, scale. = F)

    features <- cbind(-pca$rotation[,'PC1'] * pca$sdev[1],
        pca$rotation[,'PC2'] * pca$sdev[2])

    idx <- clustKmeans(features)

    features <- as.data.frame(features)
    features$cluster <- FALSE
    features$cluster[idx] <- TRUE

    list(idx = idx, features = features)
}

#' @export
pps_scca <- function(res)
{
    AB <- t(res$AB)
    D <- t(res$D)

    # fscca::fscca(AB, D, "lasso", "lasso", 1:10, 1:10)
    s_res <- scca(AB, D, "LASSO", seq(0.05, 0.5, length.out = 5), 1:3, center = F, scale = F)
    rowIdx <- clustKmeans(abs(s_res$A), add_noise = F)
    colIdx <- clustKmeans(abs(s_res$B), add_noise = T)

    list(rowIdx = rowIdx, colIdx = colIdx)
}

#' Works column-wise
bootStrapNAs <- function(dat, lwr, upr)
{
    for (icol in 1:ncol(dat))
    {
        rng <- quantile(dat[,icol], probs = c(lwr, upr), na.rm = T)
        # FIXME: why is this not matching at least some things?
        whichValid <- which( (rng[1] <= dat[,icol]) & (dat[,icol] <= rng[2]))
        nNa <- sum(is.na(dat[,icol]))
        if (length(whichValid) == 0)
        {
            # cat("len == 0", icol, "\n")
            # print(sum(!is.na(dat[,icol])))
            whichValid <- which(!is.na(dat[,icol]))
            # print(whichValid)
            # print("----")
        }
        samps <- NA
        if (length(whichValid) == 1)
            samps <- rep.int(whichValid, nNa)
        else
            samps <- sample(whichValid, nNa, replace = T)

        dat[is.na(dat[,icol]), icol] <- dat[samps,icol]
        # if (any(is.na(dat[,icol])))
        # {
        #     cat("samples:", icol, "\n")
        #     print(dat[samps,icol])
        #     print("whichValid values:")
        #     print(dat[whichValid,icol])
        #     print("whichValid:")
        #     print(length(whichValid))
        #     print(whichValid)
        # }
    }

    return(dat)
}

#' count indeces
#'
#' @param idx a vector of indices (usually integer) with repeating values
#' @return a data.frame with columns "index" referring to the index and
#' "count", the count of the index
count_index <- function(idx)
{
    counts <- reshape2::melt(idx) %>%
        group_by(value) %>%
        summarise(count = length(value)) %>%
        rename(index = value)

    counts
}

#' @export
pps_sub <- function(sub_res, prop, n_rows, pps_fun)
{
    each_idx <- lapply(sub_res, function(x)
    {
        translate_idx(x$samp_idx,
            pps_fun(x$result$AB)$idx)
    })
    lapply(sub_res, function(x) intersect(1:300, x$i))

    count_table <- table(unlist(each_idx))
    m_count_table <- reshape2::melt(count_table, varnames = c("idx"),
        value.name = "count")
    gt <- dplyr::filter(
        m_count_table,
        count > prop * length(each_idx))
    row_idx <- gt$idx

    # deal w/ cols
    each_idx <- lapply(sub_res, function(x)
    {
            pps_fun(x$result$D)$idx
    })

    count_table <- table(unlist(each_idx))
    m_count_table <- reshape2::melt(count_table, varnames = c("idx"),
        value.name = "count")
    gt <- dplyr::filter(
        m_count_table,
        count > prop * length(each_idx))
    col_idx <- gt$idx

    list(rowIdx = row_idx, colIdx = col_idx)
}


################################################################################
# old functions
################################################################################

#' @export
pss_hclust <- function(s_res)
{
    stopifnot( is(s_res, "sccab_result") )

    A <- s_res$AB
    D <- s_res$D

    cutHCluster <- function(mat)
    {
        hc <- hclust(dist(mat))
        hcCuts <- cutree(hc, 2)

        cutIdx <- 1
        if (mean(mat[which(hcCuts == 1), ]) <
            mean(mat[which(hcCuts == 2), ]))
        {
            cutIdx <- 2
        }
        cutIdx <- which(hcCuts == cutIdx)

        return(cutIdx)
    }

    rowIdx <- cutHCluster(A)
    colIdx <- cutHCluster(D)

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}
#' @export
pss_pca_old <- function(s_res)
{
    stopifnot( is(s_res, "sccab_result") )

    ab <- t(s_res$AB)
    d <- t(s_res$D)

    if (any(is.na(ab)))
        ab <- bootStrapNAs(t(ab), 0.05, 0.95)

    pcaAB <- prcomp(ab, center = F, scale. = F)
    # pcaAB <- prcomp(ab)
    pcaAB$rotation <- as.data.frame(data.matrix(as.data.frame(pcaAB$rotation, stringsAsFactors = F)))

    pcaAB$rotation[,"mean"] <- apply(ab, 2, mean, na.rm = T)
    pcaAB$rotation[,"sd"] <- apply(ab, 2, sd, na.rm = T)
    pcaAB$rotation[,"median"] <- apply(ab, 2, median, na.rm = T)
    pcaAB$rotation[,"var"] <- apply(ab, 2, var, na.rm = T)
    pcaAB$rotation[,"cov"] <- with(pcaAB$rotation, sd / mean)

    pcaD <- prcomp(d, center = F, scale. = F)
    # dQuant <- apply(d, 2, quantile, probs = dQuant, na.rm = T)
    dSd <- apply(d, 2, sd, na.rm = T)


    # colIdx <- clustKmeans(cbind(dQuant, dSd))
    # rowIdx <- clustKmeans(with(pcaAB$rotation, cbind(-PC1 * sdev[1], PC2 * sdev[2])))

    df <- cbind(-pcaAB$rotation$PC1 * pcaAB$sdev[1],
                                pcaAB$rotation$PC2 * pcaAB$sdev[2])
    rowIdx <- clustKmeans(df)
    df2 <- cbind(-pcaD$rotation[,"PC1"] * pcaD$sdev[1],
        rnorm(nrow(pcaD$rotation), sd = 0.0001))
                 # pcaD$rotation[,"PC2"] * pcaD$sdev[2])
    colIdx <- clustKmeans(df2)

    pcaAB$rotation$cluster <- FALSE
    pcaAB$rotation$cluster[rowIdx] <- TRUE

    pcaD$rotation <- data.frame(pcaD$rotation)
    pcaD$rotation[,"cluster"] <- "background"
    pcaD$rotation[colIdx,"cluster"] <- "bicluster"

    return(list(
            abDat = data.frame(pcaAB$rotation),
            dDat = data.frame(pcaD$rotation),
            rowIdx = rowIdx, colIdx = colIdx))
}
#' @export
pss_ranks <- function(s_res)
{
    stopifnot( is(s_res, "sccab_result") )

    ab <- s_res$AB
    if (any(is.na(ab)))
        ab <- bootStrapNAs(ab, 0.05, 0.95)

    ab_rank <- apply(ab, 2, rank, na.last = "keep")
    print(dim(ab))

    pca_ab <- prcomp(t(ab_rank), center = F, scale. = F)
    ab_features <- cbind(-pca_ab$rotation[,1] * pca_ab$sdev[1],
        pca_ab$rotation[,2] * pca_ab$sdev[2])
    rowIdx <- clustKmeans(ab_features)
    ab_features <- data.frame(ab_features)
    colnames(ab_features) <- c("PC1", "PC2")
    ab_features$in_clust <- FALSE
    ab_features$in_clust[rowIdx] <- TRUE


    d <- s_res$D
    d_rank <- apply(d, 2, rank)
    pca_d <- prcomp(t(d), center = F, scale. = F)

    d_features <- cbind(-pca_d$rotation[,1] * pca_d$sdev[1],
        pca_d$rotation[,2] * pca_d$sdev[2])
    colIdx <- clustKmeans(d_features)
    d_features <- data.frame(d_features)
    colnames(d_features) <- c("PC1", "PC2")
    d_features$in_clust <- FALSE
    d_features$in_clust[colIdx] <- TRUE

    return(list(ab_rank = ab_rank, rowIdx = rowIdx, ab_features = ab_features,
            colIdx = colIdx, d_features = d_features))
}

postSubSample <- function(subSampleSol, percentile = 0.75)
{
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abGt <- apply(ab, 2, function(col) {
                  # median(col, na.rm = TRUE)
                  mean(col, na.rm = TRUE)
                  # quantile(col, probs = percentile, na.rm = TRUE)
            })
    dGt <- apply(d, 2, function(col)
                  {
                      median(col, na.rm = TRUE)
                  })
    # dGt <- t(dGt)
    return(list(ab = abGt, d = dGt))
}


postSubSample.percent <- function(subSampleSol, percentile = 0.95, eps = 0.05)
{
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- sapply(subSampleSol, function (x) x$d)
    # want to implement in top 5%, 90% it is chosen
    abGt <- apply(ab, 1, function(row) {
                  # median(col, na.rm = TRUE)
                  row >= quantile(row, probs = percentile, na.rm = TRUE)
            })
    rowIdx <- which(apply(abGt, 1, mean, na.rm = T) >= eps)
    # dGt <- apply(d, 1, function(row)
    #               {
    #                   row >= quantile(row, probs = percentile, na.rm = TRUE)
    #               })
    # dGt <- t(dGt)
    # colIdx <- which(apply(d, 1, mean, na.rm = T) >= eps)

    cutHCluster <- function(mat)
    {
        hc <- hclust(dist(mat))
        hcCuts <- cutree(hc, 2)

        cutIdx <- 1
        if (mean(mat[which(hcCuts == 1), ]) <
            mean(mat[which(hcCuts == 2), ]))
        {
            cutIdx <- 2
        }
        cutIdx <- which(hcCuts == cutIdx)

        return(cutIdx)
    }

    colIdx <- cutHCluster(d)


    return(list(rowIdx = rowIdx, colIdx = colIdx))
}


postSubSample.percent2 <- function(subSampleSol, percentile1 = 0.95, eps1 = 0.5,
                                   percentile2 = 0.95, eps2 = 0.5)
{
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))
    # want to implement in top 5%, 90% it is chosen
    abGt <- apply(ab, 1, function(row) {
                  # median(col, na.rm = TRUE)
                  row >= quantile(row, probs = percentile1, na.rm = TRUE)
            })
    rowIdx <- which(apply(abGt, 1, mean, na.rm = T) >= eps1)

    dGt <- apply(d, 1, function(row) {
                 row >= quantile(row, probs = percentile2, na.rm = T)
            })
    colIdx <- which(apply(dGt, 1, mean, na.rm = T) >= eps2)

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}

postSubSample.sort <- function(subSampleSol, percentile1 = 0.95, eps1 = 0.5,
                               percentile2 = 0.95, eps2 = 0.5)
{
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))
    # want to implement in top 5%, 90% it is chosen
    abGt <- apply(ab, 1, function(row) {
                  # median(col, na.rm = TRUE)
                  row >= quantile(row, probs = percentile1, na.rm = TRUE)
                               })
    rowIdx <- which(apply(abGt, 1, mean, na.rm = T) >= eps1)

    dSort <- t(apply(d, 2, function(col) {sort(col)}))
    cutHCluster <- function(mat)
    {
        hc <- hclust(dist(mat))
        hcCuts <- cutree(hc, 2)

        cutIdx <- 1
        if (mean(mat[which(hcCuts == 1), ]) <
            mean(mat[which(hcCuts == 2), ]))
        {
            cutIdx <- 2
        }
        cutIdx <- which(hcCuts == cutIdx)

        return(cutIdx)
    }
    colIdx <- cutHCluster(dSort)

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}

postSubSample.top <- function(subSampleSol, percentile1 = 0.95, eps1 = 0.5,
                               nc)
{
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- sapply(subSampleSol, function (x) x$d)
    # want to implement in top 5%, 90% it is chosen
    abGt <- apply(ab, 1, function(row) {
                  # median(col, na.rm = TRUE)
                  row >= quantile(row, probs = percentile1, na.rm = TRUE)
                               })
    rowIdx <- which(apply(abGt, 1, mean, na.rm = T) >= eps1)

    dMean <- apply(d, 1, mean)
    colIdx <- order(dMean, decreasing = T)[1:nc]

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}


postSubSample.median <- function(subSampleSol, abQuant = 0.5)
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abMed <- apply(ab, 2, quantile, probs = abQuant, na.rm = T)
    dMed <- apply(d, 2, median)

    return(list(ab = abMed, d = dMed))
}


postSubSample.median.kmeans <- function(subSampleSol, abQuant = 0.5, dQuant = 0.5,
                                      seMethod = "firstSEmax")
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abQuant <- apply(ab, 2, quantile, probs = abQuant, na.rm = T)
    abSd <- apply(ab, 2, sd, na.rm = T)
    dQuant <- apply(d, 2, quantile, probs = dQuant, na.rm = T)
    dSd <- apply(d, 2, sd, na.rm = T)

    clustKmeans <- function(dat)
    {
        gap <- clusGap(as.matrix(dat), kmeans, 5)
        nk <- maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"])
        if (nk == 1)
            nk <- 2
        kRes <- kmeans(dat, nk, nstart = 20)
        kMax <- which.max(kRes$centers[,1])

        which(kRes$cluster == kMax)
    }

    rowIdx <- clustKmeans(cbind(abQuant, abSd, abQuant / abSd))
    colIdx <- clustKmeans(cbind(dQuant, dSd))

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}


# credit to stackoverflow:
# http://stackoverflow.com/questions/2547402/standard-library-function-in-r-for-finding-the-mode
findMode <- function(x, na.rm = T)
{
    if (na.rm)
        x <- x[!is.na(x)]
    ux <- unique(x)
    if (length(ux) == length(x))
        print("ERROR: No mode")
    ux[which.max(tabulate(match(x, ux)))]
}

postSubSample.median.kmeans2 <- function(subSampleSol, abQuant = 0.5, dQuant = 0.5,
                                         seMethod = "firstSEmax")
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abStats <- data.frame(med = apply(ab, 2, quantile, probs = abQuant, na.rm = T),
                          upr = apply(ab, 2, quantile, probs = 0.75, na.rm = T),
                          mode = apply(round(ab, digits = 3), 2, findMode, na.rm = T),
                          sd = apply(ab, 2, sd, na.rm = T),
                          min = apply(ab, 2, min, na.rm = T))
    abStats$medRate <- with(abStats, med / sd)
    abStats$mean <- apply(ab, 2, mean, na.rm = T)
    dQuant <- apply(d, 2, quantile, probs = dQuant, na.rm = T)
    dSd <- apply(d, 2, sd, na.rm = T)

    # abMode <- apply(round(ab, digits = 3), 2, findMode, na.rm = T)

    clustKmeans <- function(dat, minK = 2)
    {
        gap <- cluster::clusGap(as.matrix(dat), kmeans, 5)
        nk <- cluster::maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"])
        if (nk == 1)
            nk <- minK
        kRes <- kmeans(dat, nk, nstart = 20)
        kMax <- which.max(kRes$centers[,1])

        which(kRes$cluster == kMax)
    }

    # rowIdx <- clustKmeans(abStats, 3)
    rowIdx <- clustKmeans(with(abStats, cbind(medRate, sd)), 3)
    # clustKmeans(with(abStats, cbind(med, sd)), 2)
    # clustKmeans(with(abStats, cbind(mode, medRate)), 3)
    # clustKmeans(with(abStats, cbind(mean, medRate)), 3)
    # clustKmeans(with(abStats, cbind(mean, sd, medRate)), 3)
    # clustKmeans(with(abStats, cbind(medRate, sd)), 4)

    # mat <- with(abStats, as.matrix(cbind(medRate, sd)))
    colIdx <- clustKmeans(cbind(dQuant, dSd))

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}

postSubSample.tight <- function(subSampleSol, abThresh = 0.6, dQuant = 0.5)
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abStats <- data.frame(med = apply(ab, 2, median, na.rm = T),
                          upr = apply(ab, 2, quantile, probs = 0.75, na.rm = T),
                          mode = apply(round(ab, digits = 3), 2, findMode, na.rm = T),
                          sd = apply(ab, 2, sd, na.rm = T),
                          min = apply(ab, 2, min, na.rm = T))
    abStats$medRate <- with(abStats, med / sd)
    abStats$mean <- apply(ab, 2, mean, na.rm = T)

    dQuant <- apply(d, 2, quantile, probs = dQuant, na.rm = T)
    dSd <- apply(d, 2, sd, na.rm = T)


    tight <- function(dat, minK = 2, maxK = 7, thresh = abThresh)
    {
        getBestClust <- function(df, theK)
        {
            kRes <- kmeans(df, theK, nstart = 20)
            kMax <- which.max(kRes$centers[,1])

            which(kRes$cluster == kMax)

        }
        clusts <- lapply(minK:maxK, function(curK)
                         {
                             getBestClust(dat, curK)
                         })
        vs <- sapply((minK+1):maxK, function(curK)
                     {
                         vScore( clusts[[curK - minK]], clusts[[curK - minK + 1]] )
                     })
        vsGt <- min(which(vs >= thresh))
        bestK <- minK + vsGt

        cat("Choosing tight cluster: ", bestK, "\n")
        getBestClust(dat, bestK)
    }

    # rowIdx <- with(abStats, tight(cbind(medRate, sd)))
    # rowIdx <- with(abStats, tight(cbind(medRate)))
    # rowIdx <- with(abStats, tight(cbind(med, sd)))
    # rowIdx <- with(abStats, tight(cbind(med, sd)))

    clustKmeans <- function(dat, minK = 2)
    {
        gap <- cluster::clusGap(as.matrix(dat), kmeans, 5)
        nk <- cluster::maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"])
        if (nk == 1)
            nk <- minK
        cat("Conditions k: ", nk, "\n")
        kRes <- kmeans(dat, nk, nstart = 20)
        kMax <- which.max(kRes$centers[,1])

        which(kRes$cluster == kMax)
    }

    # colIdx <- clustKmeans(cbind(dQuant, dSd))
    colIdx <- clustKmeans(cbind(dQuant))

    return(list(abDat = abStats, cluster = list(rowIdx = rowIdx, colIdx = colIdx)))
}



postSubSample.tightPCA <- function(subSampleSol, abThresh = 0.6, dQuant = 0.5)
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    bootStrapNAs <- function(dat, lwr, upr)
    {
        for (col in 1:ncol(dat))
        {
            rng <- quantile(dat[,col], probs = c(lwr, upr), na.rm = T)
            whichValid <- which(rng[1] <= dat[,col] & dat[,col] <= rng[2])
            nNa <- sum(is.na(dat[,col]))
            dat[is.na(dat[,col]), col] <- dat[sample(whichValid, nNa, replace = T), col]
        }

        return(dat)
    }

    # replace NAs w/ a bootstrap
    ab <- bootStrapNAs(ab, 0.05, 0.95)

    pcaAB <- prcomp(ab, center = F, scale. = F)
    pcaAB$rotation <- as.data.frame(data.matrix(as.data.frame(pcaAB$rotation, stringsAsFactors = F)))
    pcaAB$rotation[,"median"] <- apply(ab, 2, median, na.rm = T)
    pcaAB$rotation[,"mean"] <- apply(ab, 2, mean, na.rm = T)
    pcaAB$rotation[,"var"] <- apply(ab, 2, var, na.rm = T)
    pcaAB$rotation[,"sd"] <- apply(ab, 2, sd, na.rm = T)
    pcaAB$rotation[,"cov"] <- pcaAB$rotation[,"sd"] / pcaAB$rotation[,"mean"]

    dQuant <- apply(d, 2, quantile, probs = dQuant, na.rm = T)
    dSd <- apply(d, 2, sd, na.rm = T)

    # pcaAB$rotation[,c("PC2")] <- 0
    pcaAB$rotation[,"zeros"] <- 0

    # df <- pcaAB$rotation[,c("PC1", "PC2", "cov")]
    df <- pcaAB$rotation[,c("PC1", "zeros")]
    # df <- pcaAB$rotation[,c("PC1", "cov")]
    # df <- pcaAB$rotation[,c("PC1", "PC2")]


    # what if you remove the things that are so far away in distn
    # toInc <- which(df[,1] <= quantile(df[,1], probs = 0.5) )
    toInc <- which(df[,1] <= quantile(df[,1], probs = 1) )
    tc <- tight.clust(df[toInc,], 5, 10, standardize.gene = F)
    # tc <- tight.clust(df[toInc,], 2, 7, standardize.gene = F)
    pcaAB$rotation[,"cluster"] <- -1
    pcaAB$rotation[toInc,"cluster"] <- tc$cluster
    pcaAB$rotation[,"cluster"] <- as.factor(pcaAB$rotation[,"cluster"])
    clustCenter <- pcaAB$rotation %.% group_by(cluster) %.% summarize(center = mean(PC1)) 
    minClust <- which.min(clustCenter$center)
    # minClust <- 1

    # rowIdx <- which(1  == pcaAB$rotation[,"cluster"])
    rowIdx <- which(minClust  == pcaAB$rotation[,"cluster"])


    clustKmeans <- function(dat, minK = 2)
    {
        gap <- clusGap(as.matrix(dat), kmeans, 5)
        nk <- maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"])
        if (nk == 1)
            nk <- minK
        cat("Conditions k: ", nk, "\n")
        kRes <- kmeans(dat, nk, nstart = 20)
        kMax <- which.max(kRes$centers[,1])

        which(kRes$cluster == kMax)
    }

    # colIdx <- clustKmeans(cbind(dQuant, dSd))
    colIdx <- clustKmeans(cbind(dQuant))

    return(list(abDat = pcaAB$rotation, tc = tc$cluster, cluster = list(rowIdx = rowIdx, colIdx = colIdx)))
    return(list(rowIdx = rowIdx, colIdx = colIdx))
}


# Each row is a gene, each column is a different iteration
getA <- function(bcSol, takeAbs = T)
{
    if (takeAbs)
        return( abs(sapply(bcSol, function (x) x$ab)) )

    sapply(bcSol, function (x) x$ab)
}

# Each row is a condition, each column is a different iteration
getD <- function(bcSol)
{
    sapply(bcSol, function (x) x$d)
}

postSubSample.mean.kmeans <- function(subSampleSol, abQuant = 0.5, dQuant = 0.5,
                                      seMethod = "firstSEmax")
{
    # rows are different permutations,
    # columns are the genes or conditions
    ab <- t(sapply(subSampleSol, function (x) abs(x$ab)))
    d <- t(sapply(subSampleSol, function (x) x$d))

    abQuant <- apply(ab, 2, mean, na.rm = T)
    dQuant <- apply(d, 2, mean,na.rm = T)

    clustKmeans <- function(dat)
    {
        gap <- clusGap(as.matrix(dat), kmeans, 5)
        nk <- maxSE(gap$Tab[,"gap"], gap$Tab[,"SE.sim"], method = seMethod)
        if (nk == 1)
            nk <- 2
        kRes <- kmeans(dat, nk, nstart = 20)
        kMax <- which.max(kRes$centers)

        which(kRes$cluster == kMax)
    }

    rowIdx <- clustKmeans(abQuant)
    colIdx <- clustKmeans(dQuant)

    return(list(rowIdx = rowIdx, colIdx = colIdx))
}


post.hclust <- function(postSample, nAB = 3, nD = 2)
{
    clustAB <- cutree(hclust(dist(postSample$ab)), nAB)
    clustABCenter <- sapply(unique(clustAB),
                            function(it) median(postSample$ab[which(clustAB == it)]))
    clustABMax <- which.max(clustABCenter)
    rowIdx <- which(clustAB == clustABMax)

    clustD <- cutree(hclust(dist(postSample$d)), nD)
    clustDCenter <- sapply(unique(clustD),
                           function(it) median(postSample$d[which(clustD == it)]))
    clustDMax <- which.max(clustDCenter)
    colIdx <- which(clustD == clustDMax)
    list(list(rowIdx = rowIdx, colIdx = colIdx))
}

post.kmeans <- function(postSample, nAB = 3, nD = 2)
{
    kClustAB <- kmeans(postSample$ab, nAB)
    kClustABMax <- which.max(kClustAB$centers)
    rowIdx <- which(kClustAB$cluster == kClustABMax)

    clustD <- kmeans(postSubSample$d, nD)
    clustDMax <- which.max(clustD$center)
    colIdx <- which(clustD$cluster == clustDMax)

    list(list(rowIdx = rowIdx, colIdx = colIdx))
}
